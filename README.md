<div align="center">
  <img width="494" height="244" src="https://github.com/goavengers/go-principles/blob/master/img/solid_2x.png">
  <h1>Философия архитектуры ООП, SOLID-принципы, Dry, KISS и YAGNI</h1>
  <h5>Вместе мы разберемся!</h5>
</div>

## Содержание

1. OOP (Object Oriented Programming)
2. SOLID
3. DRY - Don’t repeat yourself
4. KISS (Keep it simple, stupid!)
5. Avoid Creating a YAGNI (You aren’t going to need it)
6. LOD (Law of Demeter)

## SOLID

За этой аббревиатурой скрываются 5 базовых принципов ООП, предложенные __Робертом Мартином__ в его статье [«Принципы проектирования и шаблоны проектирования»](https://web.archive.org/web/20150906155800/http://www.objectmentor.com/resources/articles/Principles_and_Patterns.pdf). Следование их духу сделает код легко тестируемым, расширяемым, читаемым и поддерживаемым.

Вот шпаргалка по этим принципам:

- (__S__) Single Responsibility Principle (принцип единственности ответственности)
- (__O__) Open/Closed Principle (принцип открытости/закрытости)
- (__L__) Liskov Substitution Principle (принцип подстановки Барбары Лисков)
- (__I__) Interface Segregation Principle (принцип разделения интерфейса) 
- (__D__) Dependency Inversion Principle (принцип инверсии зависимостей) 

По словам __Роберта С. Мартина__, симптомы гниющего дизайна или плохого кода:

- __Жесткость__ (трудно менять код, так как простое изменение затрагивает много мест);
- __Неподвижность__ (сложно разделить код на модули, которые можно использовать в других программах);
- __Вязкость__ (разрабатывать и/или тестировать код довольно тяжело);
- __Ненужная Сложность__ (в коде есть неиспользуемый функционал);
- __Ненужная Повторяемость__ (Copy/Paste);
- __Плохая Читабельность__ (трудно понять что код делает, трудно его поддерживать);
- __Хрупкость__ (легко поломать функционал даже небольшими изменениями);

Но это улучшение, теперь мы можем сказать что то вроде "мне не нравится это потому, что слишком сложно модифицировать", или "мне не нравится это потому, что я не могу сказать, что этот код пытается сделать", но что насчет того, чтобы вести обсуждение позитивно?

Разве это не было бы здорово, если бы существовал способ описать свойства хорошего дизайна, а не только плохого и иметь возможность рассуждать объективными терминами? Для этого нам на помощь спешат принципы проектирования архитектуры и написания программного кода.

Сейчас мы рассмотрим эти принципы на схематичных примерах. Обратите внимание на то, что главная цель примеров заключается в том, чтобы помочь читателю понять принципы __SOLID__, узнать, как их применять и как следовать им, проектируя приложения. Автор материала не стремился к тому, чтобы выйти на работающий код, который можно было бы использовать в реальных проектах.

В golang в качестве отдельных частей у нас есть - пакаджи, структуры, методы и интерфейсы. Давайте расссмотрим SOLID в этих терминах.

### Single Responsibility Principle (принцип единственности ответственности)

На самом верхнем уровне мы декомпозируем систему на пакаджи. В соответствии с этим принципом каждый пакадж должен заниматься какой-то отдельной вещью.

Дальше пакадж мы делим на структуры с набором методов. Каждая структура и связанные с ней методы несут отвественность за какую-то более специфическую задачу внутри пакаджа.

Каждый метод структуры выполняет какую-то одну единственную задачу.

### Open/Closed Principle (принцип открытости/закрытости)

> Система должна быть открыта для расширения и закрыта для модификации.

В какой-то момент у нас уже есть правильно работающая система и для добавления нового функционала мы не модифицируем тот код, который уже есть, а добавляем новый.

В каких-то случаях мы можем воспользоваться embedded типами.

У нас есть базовый класс с устоявшейся функциональностью (структура с методами) и мы можем расширить его засчет embedding механизма в наследнике.

```go
package main

import (
	"fmt"
)

type A struct {
}

func (*A) ask() {
	fmt.Println("Скажите, пожалуйста!")
}

type B struct {
	*A
}

func (p *B) tell() {
	fmt.Println("Конечно, конечно!")
}

func main() {
	var b B
	b.ask()
	b.tell()
}
```

В каких-то случаях подойдет переопределение типов:

```go
package main

import "fmt"

type N int64

func (i N) print() {
	fmt.Println(i)
}

func main() {
	var k N = 1
	k.print()
}
```

Но с любым наследованием, как мне кажется, лучше обращаться с осторожностью. Если создать цепочку наследования из 15 классов, каждый из которых расширяет последующий, мы вроде бы и следуем OCP принципу, но код от этого не станет понятнее.

Т.е. всегда в качестве проверки - декомпозиция, связанность модулей. Стала система понятнее или нет?

На мой взгляд интереснее вариант на основе интерфейсов - есть постоянная часть, которая не изменяется (интерфейс), и различные имплементации (расширения) этого интерфейса, которые мы можем подключать.

Uncle Bob в своей [статье](https://blog.cleancoder.com/uncle-bob/2014/05/12/TheOpenClosedPrinciple.html) указывает, что крайнее проявление такого подхода - это архитектура на основе плагинов.

Тот же автор [приводит](https://drive.google.com/file/d/0BwhCYaYDn8EgN2M5MTkwM2EtNWFkZC00ZTI3LWFjZTUtNTFhZGZiYmUzODc1/view), в качестве примера OCP, отрисовку фигур:

У нас есть метод который отрисовывает набор фигур

```go
func DrawAllShapes(shapes []Shape) {
	for _, sh := range shapes {
		sh.Draw()
	}
}
```

И интерфейс отрисовки

```go
type Shape interface {
	Draw()
}
```

Метод и интерфейс фиксированны, а расширять систему мы можем засчет добавления имплементаций этого интерфейса

```go
package main

import "fmt"

type Shape interface {
	Draw()
}

func DrawAllShapes(shapes []Shape) {
	for _, sh := range shapes {
		sh.Draw()
	}
}

type Circle struct {
}

func (p *Circle) Draw() {
	fmt.Println("Draw cirle!")
}

type Square struct {
}

func (p *Square) Draw() {
	fmt.Println("Draw square!")
}

func main() {
	shapes := []Shape{&Circle{}, &Square{}}
	DrawAllShapes(shapes)
}
```

Декомпозируем мы систему на отдельные модули? Да.
Стала система понятнее? На мой взгляд, да.

Т.е. определяем в системе более постоянные части и отделяем их интерфейсом от более изменчивых.

### Liskov Substitution Principle (принцип подстановки Барбары Лисков)


### Interface Segregation Principle (принцип разделения интерфейса) 


### Dependency Inversion Principle (принцип инверсии зависимостей) 


